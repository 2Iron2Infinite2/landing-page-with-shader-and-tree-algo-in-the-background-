{
  "version": 3,
  "sources": ["../../tinyglobby/dist/index.mjs"],
  "sourcesContent": ["import nativeFs from \"fs\";\nimport path, { posix } from \"path\";\nimport { fileURLToPath } from \"url\";\nimport { fdir } from \"fdir\";\nimport picomatch from \"picomatch\";\n\n//#region src/utils.ts\nconst isReadonlyArray = Array.isArray;\nconst isWin = process.platform === \"win32\";\nconst ONLY_PARENT_DIRECTORIES = /^(\\/?\\.\\.)+$/;\nfunction getPartialMatcher(patterns, options = {}) {\n\tconst patternsCount = patterns.length;\n\tconst patternsParts = Array(patternsCount);\n\tconst matchers = Array(patternsCount);\n\tconst globstarEnabled = !options.noglobstar;\n\tfor (let i = 0; i < patternsCount; i++) {\n\t\tconst parts = splitPattern(patterns[i]);\n\t\tpatternsParts[i] = parts;\n\t\tconst partsCount = parts.length;\n\t\tconst partMatchers = Array(partsCount);\n\t\tfor (let j = 0; j < partsCount; j++) partMatchers[j] = picomatch(parts[j], options);\n\t\tmatchers[i] = partMatchers;\n\t}\n\treturn (input) => {\n\t\tconst inputParts = input.split(\"/\");\n\t\tif (inputParts[0] === \"..\" && ONLY_PARENT_DIRECTORIES.test(input)) return true;\n\t\tfor (let i = 0; i < patterns.length; i++) {\n\t\t\tconst patternParts = patternsParts[i];\n\t\t\tconst matcher = matchers[i];\n\t\t\tconst inputPatternCount = inputParts.length;\n\t\t\tconst minParts = Math.min(inputPatternCount, patternParts.length);\n\t\t\tlet j = 0;\n\t\t\twhile (j < minParts) {\n\t\t\t\tconst part = patternParts[j];\n\t\t\t\tif (part.includes(\"/\")) return true;\n\t\t\t\tconst match = matcher[j](inputParts[j]);\n\t\t\t\tif (!match) break;\n\t\t\t\tif (globstarEnabled && part === \"**\") return true;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (j === inputPatternCount) return true;\n\t\t}\n\t\treturn false;\n\t};\n}\n/* node:coverage ignore next 2 */\nconst WIN32_ROOT_DIR = /^[A-Z]:\\/$/i;\nconst isRoot = isWin ? (p) => WIN32_ROOT_DIR.test(p) : (p) => p === \"/\";\nfunction buildFormat(cwd, root, absolute) {\n\tif (cwd === root || root.startsWith(`${cwd}/`)) {\n\t\tif (absolute) {\n\t\t\tconst start = isRoot(cwd) ? cwd.length : cwd.length + 1;\n\t\t\treturn (p, isDir) => p.slice(start, isDir ? -1 : void 0) || \".\";\n\t\t}\n\t\tconst prefix = root.slice(cwd.length + 1);\n\t\tif (prefix) return (p, isDir) => {\n\t\t\tif (p === \".\") return prefix;\n\t\t\tconst result = `${prefix}/${p}`;\n\t\t\treturn isDir ? result.slice(0, -1) : result;\n\t\t};\n\t\treturn (p, isDir) => isDir && p !== \".\" ? p.slice(0, -1) : p;\n\t}\n\tif (absolute) return (p) => posix.relative(cwd, p) || \".\";\n\treturn (p) => posix.relative(cwd, `${root}/${p}`) || \".\";\n}\nfunction buildRelative(cwd, root) {\n\tif (root.startsWith(`${cwd}/`)) {\n\t\tconst prefix = root.slice(cwd.length + 1);\n\t\treturn (p) => `${prefix}/${p}`;\n\t}\n\treturn (p) => {\n\t\tconst result = posix.relative(cwd, `${root}/${p}`);\n\t\tif (p.endsWith(\"/\") && result !== \"\") return `${result}/`;\n\t\treturn result || \".\";\n\t};\n}\nconst splitPatternOptions = { parts: true };\nfunction splitPattern(path$1) {\n\tvar _result$parts;\n\tconst result = picomatch.scan(path$1, splitPatternOptions);\n\treturn ((_result$parts = result.parts) === null || _result$parts === void 0 ? void 0 : _result$parts.length) ? result.parts : [path$1];\n}\nconst ESCAPED_WIN32_BACKSLASHES = /\\\\(?![()[\\]{}!+@])/g;\nfunction convertPosixPathToPattern(path$1) {\n\treturn escapePosixPath(path$1);\n}\nfunction convertWin32PathToPattern(path$1) {\n\treturn escapeWin32Path(path$1).replace(ESCAPED_WIN32_BACKSLASHES, \"/\");\n}\n/**\n* Converts a path to a pattern depending on the platform.\n* Identical to {@link escapePath} on POSIX systems.\n* @see {@link https://superchupu.dev/tinyglobby/documentation#convertPathToPattern}\n*/\n/* node:coverage ignore next 3 */\nconst convertPathToPattern = isWin ? convertWin32PathToPattern : convertPosixPathToPattern;\nconst POSIX_UNESCAPED_GLOB_SYMBOLS = /(?<!\\\\)([()[\\]{}*?|]|^!|[!+@](?=\\()|\\\\(?![()[\\]{}!*+?@|]))/g;\nconst WIN32_UNESCAPED_GLOB_SYMBOLS = /(?<!\\\\)([()[\\]{}]|^!|[!+@](?=\\())/g;\nconst escapePosixPath = (path$1) => path$1.replace(POSIX_UNESCAPED_GLOB_SYMBOLS, \"\\\\$&\");\nconst escapeWin32Path = (path$1) => path$1.replace(WIN32_UNESCAPED_GLOB_SYMBOLS, \"\\\\$&\");\n/**\n* Escapes a path's special characters depending on the platform.\n* @see {@link https://superchupu.dev/tinyglobby/documentation#escapePath}\n*/\n/* node:coverage ignore next */\nconst escapePath = isWin ? escapeWin32Path : escapePosixPath;\n/**\n* Checks if a pattern has dynamic parts.\n*\n* Has a few minor differences with [`fast-glob`](https://github.com/mrmlnc/fast-glob) for better accuracy:\n*\n* - Doesn't necessarily return `false` on patterns that include `\\`.\n* - Returns `true` if the pattern includes parentheses, regardless of them representing one single pattern or not.\n* - Returns `true` for unfinished glob extensions i.e. `(h`, `+(h`.\n* - Returns `true` for unfinished brace expansions as long as they include `,` or `..`.\n*\n* @see {@link https://superchupu.dev/tinyglobby/documentation#isDynamicPattern}\n*/\nfunction isDynamicPattern(pattern, options) {\n\tif ((options === null || options === void 0 ? void 0 : options.caseSensitiveMatch) === false) return true;\n\tconst scan = picomatch.scan(pattern);\n\treturn scan.isGlob || scan.negated;\n}\nfunction log(...tasks) {\n\tconsole.log(`[tinyglobby ${(/* @__PURE__ */ new Date()).toLocaleTimeString(\"es\")}]`, ...tasks);\n}\n\n//#endregion\n//#region src/index.ts\nconst PARENT_DIRECTORY = /^(\\/?\\.\\.)+/;\nconst ESCAPING_BACKSLASHES = /\\\\(?=[()[\\]{}!*+?@|])/g;\nconst BACKSLASHES = /\\\\/g;\nfunction normalizePattern(pattern, expandDirectories, cwd, props, isIgnore) {\n\tlet result = pattern;\n\tif (pattern.endsWith(\"/\")) result = pattern.slice(0, -1);\n\tif (!result.endsWith(\"*\") && expandDirectories) result += \"/**\";\n\tconst escapedCwd = escapePath(cwd);\n\tif (path.isAbsolute(result.replace(ESCAPING_BACKSLASHES, \"\"))) result = posix.relative(escapedCwd, result);\n\telse result = posix.normalize(result);\n\tconst parentDirectoryMatch = PARENT_DIRECTORY.exec(result);\n\tconst parts = splitPattern(result);\n\tif (parentDirectoryMatch === null || parentDirectoryMatch === void 0 ? void 0 : parentDirectoryMatch[0]) {\n\t\tconst n = (parentDirectoryMatch[0].length + 1) / 3;\n\t\tlet i = 0;\n\t\tconst cwdParts = escapedCwd.split(\"/\");\n\t\twhile (i < n && parts[i + n] === cwdParts[cwdParts.length + i - n]) {\n\t\t\tresult = result.slice(0, (n - i - 1) * 3) + result.slice((n - i) * 3 + parts[i + n].length + 1) || \".\";\n\t\t\ti++;\n\t\t}\n\t\tconst potentialRoot = posix.join(cwd, parentDirectoryMatch[0].slice(i * 3));\n\t\tif (!potentialRoot.startsWith(\".\") && props.root.length > potentialRoot.length) {\n\t\t\tprops.root = potentialRoot;\n\t\t\tprops.depthOffset = -n + i;\n\t\t}\n\t}\n\tif (!isIgnore && props.depthOffset >= 0) {\n\t\tvar _props$commonPath;\n\t\t(_props$commonPath = props.commonPath) !== null && _props$commonPath !== void 0 || (props.commonPath = parts);\n\t\tconst newCommonPath = [];\n\t\tconst length = Math.min(props.commonPath.length, parts.length);\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tconst part = parts[i];\n\t\t\tif (part === \"**\" && !parts[i + 1]) {\n\t\t\t\tnewCommonPath.pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (part !== props.commonPath[i] || isDynamicPattern(part) || i === parts.length - 1) break;\n\t\t\tnewCommonPath.push(part);\n\t\t}\n\t\tprops.depthOffset = newCommonPath.length;\n\t\tprops.commonPath = newCommonPath;\n\t\tprops.root = newCommonPath.length > 0 ? posix.join(cwd, ...newCommonPath) : cwd;\n\t}\n\treturn result;\n}\nfunction processPatterns({ patterns = [\"**/*\"], ignore = [], expandDirectories = true }, cwd, props) {\n\tif (typeof patterns === \"string\") patterns = [patterns];\n\tif (typeof ignore === \"string\") ignore = [ignore];\n\tconst matchPatterns = [];\n\tconst ignorePatterns = [];\n\tfor (const pattern of ignore) {\n\t\tif (!pattern) continue;\n\t\tif (pattern[0] !== \"!\" || pattern[1] === \"(\") ignorePatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, true));\n\t}\n\tfor (const pattern of patterns) {\n\t\tif (!pattern) continue;\n\t\tif (pattern[0] !== \"!\" || pattern[1] === \"(\") matchPatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, false));\n\t\telse if (pattern[1] !== \"!\" || pattern[2] === \"(\") ignorePatterns.push(normalizePattern(pattern.slice(1), expandDirectories, cwd, props, true));\n\t}\n\treturn {\n\t\tmatch: matchPatterns,\n\t\tignore: ignorePatterns\n\t};\n}\nfunction formatPaths(paths, relative) {\n\tfor (let i = paths.length - 1; i >= 0; i--) {\n\t\tconst path$1 = paths[i];\n\t\tpaths[i] = relative(path$1);\n\t}\n\treturn paths;\n}\nfunction normalizeCwd(cwd) {\n\tif (!cwd) return process.cwd().replace(BACKSLASHES, \"/\");\n\tif (cwd instanceof URL) return fileURLToPath(cwd).replace(BACKSLASHES, \"/\");\n\treturn path.resolve(cwd).replace(BACKSLASHES, \"/\");\n}\nfunction getCrawler(patterns, inputOptions = {}) {\n\tconst options = process.env.TINYGLOBBY_DEBUG ? {\n\t\t...inputOptions,\n\t\tdebug: true\n\t} : inputOptions;\n\tconst cwd = normalizeCwd(options.cwd);\n\tif (options.debug) log(\"globbing with:\", {\n\t\tpatterns,\n\t\toptions,\n\t\tcwd\n\t});\n\tif (Array.isArray(patterns) && patterns.length === 0) return [{\n\t\tsync: () => [],\n\t\twithPromise: async () => []\n\t}, false];\n\tconst props = {\n\t\troot: cwd,\n\t\tcommonPath: null,\n\t\tdepthOffset: 0\n\t};\n\tconst processed = processPatterns({\n\t\t...options,\n\t\tpatterns\n\t}, cwd, props);\n\tif (options.debug) log(\"internal processing patterns:\", processed);\n\tconst matchOptions = {\n\t\tdot: options.dot,\n\t\tnobrace: options.braceExpansion === false,\n\t\tnocase: options.caseSensitiveMatch === false,\n\t\tnoextglob: options.extglob === false,\n\t\tnoglobstar: options.globstar === false,\n\t\tposix: true\n\t};\n\tconst matcher = picomatch(processed.match, {\n\t\t...matchOptions,\n\t\tignore: processed.ignore\n\t});\n\tconst ignore = picomatch(processed.ignore, matchOptions);\n\tconst partialMatcher = getPartialMatcher(processed.match, matchOptions);\n\tconst format = buildFormat(cwd, props.root, options.absolute);\n\tconst formatExclude = options.absolute ? format : buildFormat(cwd, props.root, true);\n\tconst fdirOptions = {\n\t\tfilters: [options.debug ? (p, isDirectory) => {\n\t\t\tconst path$1 = format(p, isDirectory);\n\t\t\tconst matches = matcher(path$1);\n\t\t\tif (matches) log(`matched ${path$1}`);\n\t\t\treturn matches;\n\t\t} : (p, isDirectory) => matcher(format(p, isDirectory))],\n\t\texclude: options.debug ? (_, p) => {\n\t\t\tconst relativePath = formatExclude(p, true);\n\t\t\tconst skipped = relativePath !== \".\" && !partialMatcher(relativePath) || ignore(relativePath);\n\t\t\tif (skipped) log(`skipped ${p}`);\n\t\t\telse log(`crawling ${p}`);\n\t\t\treturn skipped;\n\t\t} : (_, p) => {\n\t\t\tconst relativePath = formatExclude(p, true);\n\t\t\treturn relativePath !== \".\" && !partialMatcher(relativePath) || ignore(relativePath);\n\t\t},\n\t\tfs: options.fs ? {\n\t\t\treaddir: options.fs.readdir || nativeFs.readdir,\n\t\t\treaddirSync: options.fs.readdirSync || nativeFs.readdirSync,\n\t\t\trealpath: options.fs.realpath || nativeFs.realpath,\n\t\t\trealpathSync: options.fs.realpathSync || nativeFs.realpathSync,\n\t\t\tstat: options.fs.stat || nativeFs.stat,\n\t\t\tstatSync: options.fs.statSync || nativeFs.statSync\n\t\t} : void 0,\n\t\tpathSeparator: \"/\",\n\t\trelativePaths: true,\n\t\tresolveSymlinks: true,\n\t\tsignal: options.signal\n\t};\n\tif (options.deep !== void 0) fdirOptions.maxDepth = Math.round(options.deep - props.depthOffset);\n\tif (options.absolute) {\n\t\tfdirOptions.relativePaths = false;\n\t\tfdirOptions.resolvePaths = true;\n\t\tfdirOptions.includeBasePath = true;\n\t}\n\tif (options.followSymbolicLinks === false) {\n\t\tfdirOptions.resolveSymlinks = false;\n\t\tfdirOptions.excludeSymlinks = true;\n\t}\n\tif (options.onlyDirectories) {\n\t\tfdirOptions.excludeFiles = true;\n\t\tfdirOptions.includeDirs = true;\n\t} else if (options.onlyFiles === false) fdirOptions.includeDirs = true;\n\tprops.root = props.root.replace(BACKSLASHES, \"\");\n\tconst root = props.root;\n\tif (options.debug) log(\"internal properties:\", props);\n\tconst relative = cwd !== root && !options.absolute && buildRelative(cwd, props.root);\n\treturn [new fdir(fdirOptions).crawl(root), relative];\n}\nasync function glob(patternsOrOptions, options) {\n\tif (patternsOrOptions && (options === null || options === void 0 ? void 0 : options.patterns)) throw new Error(\"Cannot pass patterns as both an argument and an option\");\n\tconst isModern = isReadonlyArray(patternsOrOptions) || typeof patternsOrOptions === \"string\";\n\tconst opts = isModern ? options : patternsOrOptions;\n\tconst patterns = isModern ? patternsOrOptions : patternsOrOptions.patterns;\n\tconst [crawler, relative] = getCrawler(patterns, opts);\n\tif (!relative) return crawler.withPromise();\n\treturn formatPaths(await crawler.withPromise(), relative);\n}\nfunction globSync(patternsOrOptions, options) {\n\tif (patternsOrOptions && (options === null || options === void 0 ? void 0 : options.patterns)) throw new Error(\"Cannot pass patterns as both an argument and an option\");\n\tconst isModern = isReadonlyArray(patternsOrOptions) || typeof patternsOrOptions === \"string\";\n\tconst opts = isModern ? options : patternsOrOptions;\n\tconst patterns = isModern ? patternsOrOptions : patternsOrOptions.patterns;\n\tconst [crawler, relative] = getCrawler(patterns, opts);\n\tif (!relative) return crawler.sync();\n\treturn formatPaths(crawler.sync(), relative);\n}\n\n//#endregion\nexport { convertPathToPattern, escapePath, glob, globSync, isDynamicPattern };"],
  "mappings": "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",
  "names": ["picomatch", "path", "nativeFs"]
}
